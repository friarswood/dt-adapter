// This is NOT for the winsen MH-Z19C CO2 sensor. It is for the "CO2-5000 carbon dioxide sensor" which I got on eBay, advertised as a MH-Z19C.
// The seller (https://www.ebay.co.uk/itm/224540799740?hash=item3447acb2fc:g:EawAAOSwZt1gQvWr) provided a Chinese datasheet, which is included.

#include "driver.h"
//#include "picpuserial.h"
#include "common/timestamp.h"

#ifdef HAVE_CO2_5000
#include <wiringPi.h>
#include <wiringSerial.h>  //only needed for serialOpen
#include <unistd.h> // needed for read and write
//#include <termios.h>
#endif

#include <array>

using namespace std::string_literals;

std::array<uint8_t, 2> calc_crc(const uint8_t *data, size_t len)
{
  uint8_t crc_hi = 0xFF ; /* CRC high byte initialization*/
  uint8_t crc_lo = 0xFF ; /* CRC low byte initialization*/
  const uint8_t crc_hi_lookup[] = {
    0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
    0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 ,
    0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 ,
    0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 ,
    0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 ,
    0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 ,
    0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 ,
    0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 ,
    0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
    0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 ,
    0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 ,
    0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 ,
    0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
    0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 ,
    0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 ,
    0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 ,
    0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
    0x40
  };

  const uint8_t crc_lo_lookup[] = {
    0x00 , 0xC0 , 0xC1 , 0x01 , 0xC3 , 0x03 , 0x02 , 0xC2 , 0xC6 , 0x06 , 0x07 , 0xC7 , 0x05 , 0xC5 , 0xC4 ,
    0x04 , 0xCC , 0x0C , 0x0D , 0xCD , 0x0F , 0xCF , 0xCE , 0x0E , 0x0A , 0xCA , 0xCB , 0x0B , 0xC9 , 0x09 ,
    0x08 , 0xC8 , 0xD8 , 0x18 , 0x19 , 0xD9 , 0x1B , 0xDB , 0xDA , 0x1A , 0x1E , 0xDE , 0xDF , 0x1F , 0xDD ,
    0x1D , 0x1C , 0xDC , 0x14 , 0xD4 , 0xD5 , 0x15 , 0xD7 , 0x17 , 0x16 , 0xD6 , 0xD2 , 0x12 , 0x13 , 0xD3 ,
    0x11 , 0xD1 , 0xD0 , 0x10 , 0xF0 , 0x30 , 0x31 , 0xF1 , 0x33 , 0xF3 , 0xF2 , 0x32 , 0x36 , 0xF6 , 0xF7 ,
    0x37 , 0xF5 , 0x35 , 0x34 , 0xF4 , 0x3C , 0xFC , 0xFD , 0x3D , 0xFF , 0x3F , 0x3E , 0xFE , 0xFA , 0x3A ,
    0x3B , 0xFB , 0x39 , 0xF9 , 0xF8 , 0x38 , 0x28 , 0xE8 , 0xE9 , 0x29 , 0xEB , 0x2B , 0x2A , 0xEA , 0xEE ,
    0x2E , 0x2F , 0xEF , 0x2D , 0xED , 0xEC , 0x2C , 0xE4 , 0x24 , 0x25 , 0xE5 , 0x27 , 0xE7 , 0xE6 , 0x26 ,
    0x22 , 0xE2 , 0xE3 , 0x23 , 0xE1 , 0x21 , 0x20 , 0xE0 , 0xA0 , 0x60 , 0x61 , 0xA1 , 0x63 , 0xA3 , 0xA2 ,
    0x62 , 0x66 , 0xA6 , 0xA7 , 0x67 , 0xA5 , 0x65 , 0x64 , 0xA4 , 0x6C , 0xAC , 0xAD , 0x6D , 0xAF , 0x6F ,
    0x6E , 0xAE , 0xAA , 0x6A , 0x6B , 0xAB , 0x69 , 0xA9 , 0xA8 , 0x68 , 0x78 , 0xB8 , 0xB9 , 0x79 , 0xBB ,
    0x7B , 0x7A , 0xBA , 0xBE , 0x7E , 0x7F , 0xBF , 0x7D , 0xBD , 0xBC , 0x7C , 0xB4 , 0x74 , 0x75 , 0xB5 ,
    0x77 , 0xB7 , 0xB6 , 0x76 , 0x72 , 0xB2 , 0xB3 , 0x73 , 0xB1 , 0x71 , 0x70 , 0xB0 , 0x50 , 0x90 , 0x91 ,
    0x51 , 0x93 , 0x53 , 0x52 , 0x92 , 0x96 , 0x56 , 0x57 , 0x97 , 0x55 , 0x95 , 0x94 , 0x54 , 0x9C , 0x5C ,
    0x5D , 0x9D , 0x5F , 0x9F , 0x9E , 0x5E , 0x5A , 0x9A , 0x9B , 0x5B , 0x99 , 0x59 , 0x58 , 0x98 , 0x88 ,
    0x48 , 0x49 , 0x89 , 0x4B , 0x8B , 0x8A , 0x4A , 0x4E , 0x8E , 0x8F , 0x4F , 0x8D , 0x4D , 0x4C , 0x8C ,
    0x44 , 0x84 , 0x85 , 0x45 , 0x87 , 0x47 , 0x46 , 0x86 , 0x82 , 0x42 , 0x43 , 0x83 , 0x41 , 0x81 , 0x80 ,
    0x40
  };

  uint16_t i;
  while (len--)
  {
    i = crc_lo ^ *data++;
    crc_lo = crc_hi ^ crc_hi_lookup[i];
    crc_hi = crc_lo_lookup[i];
  }

  return {crc_lo, crc_hi};
}

// last 2 bytes are checksum
bool check_crc(const uint8_t *data, size_t len)
{
  auto crc = calc_crc(data, len - 2);
  return crc[0] == data[len-2] && crc[1] == data[len-1];
}



#ifdef HAVE_CO2_5000

namespace {

const std::array<uint8_t, 5> REQUEST_CO2{0x64, 0x69, 0x01, 0xDF, 0x8F};
const std::array<uint8_t, 5> REQUEST_TEMP{0x64, 0x69, 0x01, 0x9F, 0x8E};

// TODO check endianness...
float as_float(const uint8_t* p)
{
  return *reinterpret_cast<const float*>(p);
}

float as_uint32_t(const uint8_t* p)
{
  return *reinterpret_cast<const uint32_t*>(p);
}

uint8_t read_impl(int fd, double& ppm)
{
  size_t n = write(fd, REQUEST_CO2.data(), REQUEST_CO2.size());
  if (n != REQUEST_CO2.size())
  {
    return CO2_5000::WRITE_FAILED;
  }

  delay(100); // give device time to respond

  // e.g. 64 69 01 01 D5 9E 02 44 00 00 00 00 DA C2
  //       0  1  2  3  4           8          12
  std::array<uint8_t, 14> response;

  n = read(fd, response.data(), response.size());
  if (n != response.size())
  {
    return CO2_5000::READ_FAILED; // this is a host (response) error, for device errors
  }

  if (!check_crc(response.data(),response.size()))
  {
    return CO2_5000::INVALID_CRC;
  }

  if (as_uint32_t(response.data() + 8))
  {
    return CO2_5000::INVALID_DATA;
  }

  if (response[1] == REQUEST_CO2[1] + 0x80)
  {
    return response[2];
  }
  ppm = as_float(response.data() + 4);
  return CO2_5000::OK;
}

}

#endif


CO2_5000::CO2_5000() : m_status(0)
{
#ifdef HAVE_CO2_5000
  m_id = "d3c38f28";
  // port/speed is hard-coded...
  m_fd = serialOpen("/dev/serial0", 9600);
#else
  m_id = "testing123";
  m_fd = 0;
#endif
  if (m_fd < 0)
  {
    throw std::runtime_error("Unable to open device");
  }
}


py::str CO2_5000::id() const
{
  return m_id;
}

py::str CO2_5000::type() const
{
#ifdef HAVE_CO2_5000
  return "CO2-5000";
#else
  return "CO2-5000-STUB";
#endif
}


py::str CO2_5000::status() const
{
  switch (m_status)
  {
  case OK: return "OK";
  // errors emanating from device
  case 0x05 ... 0x6: return "device busy"; // this range syntax is apparently a gcc extension (but works with clang too)
  case 0x01 ... 0x4:
  case 0x07 ... 0x10: return "device error " + std::to_string(m_status);
  // errors emanating from host
  case WRITE_FAILED: return "error writing to device";
  case READ_FAILED: return "error reading from device";
  case INVALID_CRC: return "device response crc invalid";
  case INVALID_DATA: return "device response data invalid";
  default: return "unknown error " + std::to_string(m_status);
  }
}

py::dict CO2_5000::read()
{
  py::dict result;
  result["timestamp"] = utc_now();
  double ppm{0.0};

#ifdef HAVE_CO2_5000
  m_status = read_impl(m_fd, ppm);
  // try to recover by resetting serial if error
  if (m_status != OK)
  {
    serialClose(m_fd);
    m_fd = serialOpen("/dev/serial0", 9600);
  }
#else
  // ramp up from 400 to 655 then back to 400
  static uint8_t counter = 0;
  ppm = 400.0 + counter;
  ++counter;
#endif

  result["status"] = status();
  if (m_status == CO2_5000::OK)
  {
    result["co2"] = ppm;
  }
  return result;
}

