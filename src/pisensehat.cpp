
#include "pisensehat.h"

#include <memory>
#include <chrono>
#include <ctime>

namespace {

// correction for heating from circuitry (depends on CPU usgae)
const double TEMPERATURE_CORRECTION = 2.3;

const char* utcStr(const std::chrono::system_clock::time_point t)
{
  time_t tt = std::chrono::system_clock::to_time_t(t);
  struct tm* ttt;
  ttt = gmtime(&tt);
  static char buffer[32];
  strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", ttt);
  return buffer;
}

}

std::string PiSenseHat::statusToString(PiSenseHat::Status::value status)
{
  if (status == Status::OK)
    return "OK";

  std::string statusmsg = std::to_string((int)status) + ":";
  if (status & Status::NO_PRESSURE) statusmsg += "[NO PRESSURE]";
  if (status & Status::NO_HUMIDITY) statusmsg += "[NO HUMIDITY]";
  if (status & Status::NO_IMU) statusmsg += "[NO IMU]";
  return statusmsg;
}

PiSenseHat::PiSenseHat() : m_status(0)
{
  //  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  m_settings = std::make_unique<RTIMUSettings>("RTIMULib");

  m_imu.reset(RTIMU::createIMU(m_settings.get()));
  m_pressure.reset(RTPressure::createPressure(m_settings.get()));
  m_humidity.reset(RTHumidity::createHumidity(m_settings.get()));

  if (!static_cast<bool>(m_imu) || (m_imu->IMUType() == RTIMU_TYPE_NULL))
  {
    m_status = m_status | Status::NO_IMU;
    return;
  }

  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU
  m_imu->IMUInit();

  //  this is a convenient place to change fusion parameters
  m_imu->setSlerpPower(0.02);
  m_imu->setGyroEnable(false);
  m_imu->setAccelEnable(false);
  m_imu->setCompassEnable(false);

  //  set up pressure sensor
  if (static_cast<bool>(m_pressure))
  {
    m_pressure->pressureInit();
  }
  else
  {
    m_status = m_status | Status::NO_PRESSURE;
  }

  //  set up humidity sensor
  if (static_cast<bool>(m_humidity))
  {
    m_humidity->humidityInit();
  }
  else
  {
    m_status = m_status | Status::NO_HUMIDITY;
  }

  //  poll at the rate recommended by the IMU
  usleep(m_imu->IMUGetPollInterval() * 1000);
}

PiSenseHat::~PiSenseHat()
{
}

py::str PiSenseHat::status() const
{
  return PiSenseHat::statusToString(m_status);
}

py::dict PiSenseHat::read() const
{
  py::dict result;
  result["status"] = PiSenseHat::statusToString(m_status);
  result["timestamp"] = utcStr(std::chrono::system_clock::now());

  while (!(m_status & Status::NO_IMU) && m_imu->IMURead())
  {
    RTIMU_DATA imuData = m_imu->getIMUData();

    if (m_pressure)
    {
      m_pressure->pressureRead(imuData);
      result["pressure"] = imuData.pressure;
      result["temperature"] = imuData.temperature - TEMPERATURE_CORRECTION;
    }

    if (m_humidity)
    {
      m_humidity->humidityRead(imuData);
      result["humidity"] = imuData.humidity;
    }
  }

  return result;
}

