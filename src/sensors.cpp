
#include "sensors.h"
//#include "utils/Log.h" 

#include <memory>
#include <ctime>

namespace {

// correction for heating from circuitry (depends on CPU usgae)
const double TEMPERATURE_CORRECTION = 2.3;

inline double round1(double x)
{
  return static_cast<double>(static_cast<int>(x * 10 + 5)) / 10.0;
}

const char* timeStr(const std::chrono::system_clock::time_point t)
{
  time_t tt = std::chrono::system_clock::to_time_t(t);
  struct tm* ttt;
  ttt = gmtime(&tt);
  static char buffer[32];
  strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%SZ", ttt);
  return buffer;
}

}

std::string Sensors::statusToString(Sensors::Status::value status)
{
  if (status == Status::OK)
    return "OK";

  std::string statusmsg = std::to_string((int)status) + ":"; 
  if (status & Status::NO_PRESSURE) statusmsg += "[NO PRESSURE]";
  if (status & Status::NO_HUMIDITY) statusmsg += "[NO HUMIDITY]";
  if (status & Status::NO_IMU) statusmsg += "[NO IMU]";
  return statusmsg;
}

Sensors::Sensors() : m_status(0)
{
  //  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
  m_settings = std::make_unique<RTIMUSettings>("RTIMULib");

  m_imu.reset(RTIMU::createIMU(m_settings.get()));
  m_pressure.reset(RTPressure::createPressure(m_settings.get()));
  m_humidity.reset(RTHumidity::createHumidity(m_settings.get()));

  if (!static_cast<bool>(m_imu) || (m_imu->IMUType() == RTIMU_TYPE_NULL)) 
  {
    m_status = m_status | Status::NO_IMU;
    return;
  }

  //  This is an opportunity to manually override any settings before the call IMUInit

  //  set up IMU
  m_imu->IMUInit();

  //  this is a convenient place to change fusion parameters
  m_imu->setSlerpPower(0.02);
  m_imu->setGyroEnable(false);
  m_imu->setAccelEnable(false);
  m_imu->setCompassEnable(false);

  //  set up pressure sensor
  if (static_cast<bool>(m_pressure))
  {
    m_pressure->pressureInit();
  }
  else
  {
    m_status = m_status | Status::NO_PRESSURE;
  }
  
  //  set up humidity sensor
  if (static_cast<bool>(m_humidity))
  {
    m_humidity->humidityInit();
  }
  else
  {
    m_status = m_status | Status::NO_HUMIDITY;
  }
  
  //  poll at the rate recommended by the IMU
  usleep(m_imu->IMUGetPollInterval() * 1000);
}

Sensors::~Sensors()
{
}

Sensors::Status::value Sensors::get(std::string& timestamp, double& t, double& p, double& h)
{
  // initialise to invalid values
  t = -300.0;
  p = 0.0;
  h = -100.0;
  timestamp = timeStr(std::chrono::system_clock::now()); 
      
  while (!(m_status & Status::NO_IMU) && m_imu->IMURead()) 
  {
    RTIMU_DATA imuData = m_imu->getIMUData();

    //  add the pressure data to the structure
    if (m_pressure)
    {
      m_pressure->pressureRead(imuData);
      p = round1(imuData.pressure);
      t = round1(imuData.temperature - TEMPERATURE_CORRECTION);
    }
      
    //  add the humidity data to the structure
    if (m_humidity)
    {
      m_humidity->humidityRead(imuData);
      h = round1(imuData.humidity);
    }  
  }
  
  return m_status;
}


